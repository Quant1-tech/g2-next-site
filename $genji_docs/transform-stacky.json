{"markdown":"# StackY\n\n**StackY** 转换会根据指定的通道值对标识进行分组，然后根据指定的排序方法给每组内的标识排序，然后生成新的 y 通道。在视觉上会形成垂直的栈。内置的排序方法有以下几种：\n\n- _sum_ - 根据堆叠后每个系列的 y 通道值的和进行排序\n- _value_ - 根据每个系列堆叠后 y 通道值的值升序排序\n- _series_ - 根据 series 或者 color 通道的字母序进行排序\n- _maxIndex_ - 根据每个系列最大的索性进行排序\n- _a function_ - 根据指定的函数的返回值进行排序\n- _an array_ - 根据指定的字段数据进行排序\n- _null_ - 遵循输入的顺序\n\n其中 _reverse_ 选项会对顺序进行反序。同时 _y_ 渲染会控制是用上边界的 y 还是下边界的 y1 的值生成新的 y 通道。\n\n<!-- The **stack** transform group marks into series by color or series channel, and then produce new y channel for each series by specified order, say to form vertical \"stacks\" by specified channels. The built-in order is as followed:\n\n- _sum_ - order stacks by ascending total value of corresponding series\n- _value_ - order stacks by ascending values of y channel\n- _series_ - order stacks by nature alphabetical order of series or color channel\n- _maxIndex_ - order stacks by the index of their max value of corresponding series\n- _a function_ - order stacks by the specified function of data\n- _an array_ - order stacks by the specified array of fields\n- _null_ - respect input order\n\nThe _reverse_ option reverse any of the above orders. And the _y_ option control wether using the ceil (_y_) or floor (_y1_) of stacked y channel as the new y channel. -->\n\n## 开始\n\n```js\n(() => {\n  const chart = new G2.Chart();\n\n  chart\n    .interval()\n    .data({\n      type: 'fetch',\n      value:\n        'https://gw.alipayobjects.com/os/bmw-prod/f129b517-158d-41a9-83a3-3294d639b39e.csv',\n      format: 'csv',\n    })\n    .transform({ type: 'stackY' })\n    .encode('x', 'state')\n    .encode('y', 'population')\n    .encode('color', 'age')\n    .axis('y', { tickFormatter: '~s' });\n\n  return chart.render().node();\n})();\n```\n\n## 选项\n\n| 参数    | 说明                           | 类型                                                                           | 默认值  |\n| ------- | ------------------------------ | ------------------------------------------------------------------------------ | ------- |\n| reverse | 是否降序排序                   | `boolean`                                                                      | `false` |\n| groupBy | 根据指定的通道分组             | `string \\| string[]`                                                           | `x`     |\n| orderBy | 指定排序方法                   | `'sum' \\| 'value' \\| 'series' \\| 'maxIndex' \\| 'Function' \\| string[] \\| null` | `null`  |\n| y       | 对 x 比例尺定义域进行截取      | `'y' \\| 'y1'`                                                                  | `'y'`   |\n| series  | 是否将 series 通道的值用于排序 | `boolean`                                                                      | `true`  |\n\n## 案例\n\nStackY 不仅仅适用于 Interval 标识，它还使用于 Area 和 Point 表示标识。它支持的对每一“层”的排序功能，可以大大提高分析数据的效率和图表的丰富度。\n\n### 堆叠面积图\n\n当 _orderBy_ 是 `value` 的时候，设置 _orderBy_ 为 `d => d.unemployed` 或者 `['unemployed']` 会得到相同的结果。前者是函数比较器，或者是字段比较器。\n\n```js | radio \"options: { labels: ['value', 'series', 'sum'], values: ['value', 'series', 'sum'] }; pin: false\"\norderBy = 'value';\n```\n\n```js\n(() => {\n  const chart = new G2.Chart();\n\n  chart\n    .area()\n    .data({\n      type: 'fetch',\n      value:\n        'https://gw.alipayobjects.com/os/bmw-prod/e58c9758-0a09-4527-aa90-fbf175b45925.json',\n    })\n    .transform({ type: 'stackY', orderBy: orderBy })\n    .encode('x', (d) => new Date(d.date))\n    .encode('y', 'unemployed')\n    .encode('color', 'industry')\n    .encode('shape', 'smooth')\n    .scale('x', { utc: true })\n    .axis('x', { title: 'Date' })\n    .axis('y', { tickFormatter: '~s' })\n    .legend('color', { size: 72, autoWrap: true, maxRows: 3, cols: 6 });\n\n  return chart.render().node();\n})();\n```\n\n### 出现顺序\n\n```js\n(() => {\n  const chart = new G2.Chart();\n  const xy = (node) =>\n    node\n      .encode('x', (d) => new Date(d.year))\n      .encode('y', 'revenue')\n      .encode('series', 'format');\n\n  chart.data({\n    type: 'fetch',\n    value:\n      'https://gw.alipayobjects.com/os/bmw-prod/f38a8ad0-6e1f-4bb3-894c-7db50781fdec.json',\n  });\n\n  chart\n    .area()\n    .transform({ type: 'stackY', orderBy: 'maxIndex', reverse: true })\n    .call(xy)\n    .encode('color', 'group')\n    .encode('shape', 'smooth')\n    .axis('y', { tickFormatter: '~s' });\n\n  chart\n    .line()\n    .transform({ type: 'stackY', orderBy: 'maxIndex', reverse: true, y: 'y1' })\n    .call(xy)\n    .encode('shape', 'smooth')\n    .style('stroke', 'white');\n\n  return chart.render().node();\n})();\n```\n\n### 堆叠点图\n\n```js\n(() => {\n  const chart = new G2.Chart({ height: 360 });\n\n  chart\n    .point()\n    .data({\n      type: 'fetch',\n      value:\n        'https://gw.alipayobjects.com/os/bmw-prod/88c601cd-c1ff-4c9b-90d5-740d0b710b7e.json',\n    })\n    .transform({ type: 'stackY' })\n    .encode('x', (d) => 2021 - d.birth)\n    .encode('y', (d) => (d.gender === 'M' ? 1 : -1))\n    .encode('color', 'gender')\n    .encode('shape', 'point')\n    .legend('color', { title: 'Gender' })\n    .axis('x', { title: 'Age →' })\n    .axis('y', {\n      title: '← Women · Men →',\n      tickFormatter: (d) => `${Math.abs(+d)}`,\n    })\n    .scale('x', { nice: true });\n\n  chart.lineY().data([0]).encode('y', 0).style('stroke', 'black');\n\n  return chart.render().node();\n})();\n```\n"}